<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// main.js
import { SnakeGame } from "./game.js";

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("scoreVal");
const highScoreEl = document.getElementById("highScoreVal");
const msg = document.getElementById("msg");

const gioco = new SnakeGame();

let intervallo = null;
let inPausa = false;
let highScore = 0;

/**
 * Buffer che evita input simultanei troppo rapidi.
 * La coda limita l’inserimento a due direzioni.
 */
let bufferDirezione = [];

highScoreEl.innerText = highScore;

/**
 * Disegna una singola cella del gioco con angoli arrotondati.
 * @param {number} x - Coordinata X nella griglia
 * @param {number} y - Coordinata Y nella griglia
 * @param {string} colore - Colore di riempimento
 * @param {number} [raggio=4] - Raggio dell’angolo
 */
function disegnaCella(x, y, colore, raggio = 4) {
    const size = 20;
    const padding = 1;
    const cellSize = size - padding * 2;

    ctx.fillStyle = colore;
    ctx.beginPath();

    const px = x * size + padding;
    const py = y * size + padding;

    // Forma arrotondata (fisicamente necessaria, non ovvia)
    ctx.moveTo(px + raggio, py);
    ctx.lineTo(px + cellSize - raggio, py);
    ctx.quadraticCurveTo(px + cellSize, py, px + cellSize, py + raggio);
    ctx.lineTo(px + cellSize, py + cellSize - raggio);
    ctx.quadraticCurveTo(px + cellSize, py + cellSize, px + cellSize - raggio, py + cellSize);
    ctx.lineTo(px + raggio, py + cellSize);
    ctx.quadraticCurveTo(px, py + cellSize, px, py + cellSize - raggio);
    ctx.lineTo(px, py + raggio);
    ctx.quadraticCurveTo(px, py, px + raggio, py);

    ctx.closePath();
    ctx.fill();
}

/**
 * Render dell’intero frame di gioco.
 * Responsabile solo del disegno, non della logica.
 */
function disegna() {
    ctx.clearRect(0, 0, 400, 400);

    // Griglia leggere come riferimento visivo
    ctx.strokeStyle = "#e2e8f0";
    ctx.lineWidth = 0.5;
    for (let i = 0; i &lt; gioco.dimensioneGriglia; i++) {
        ctx.beginPath(); ctx.moveTo(i * 20, 0); ctx.lineTo(i * 20, 400); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i * 20); ctx.lineTo(400, i * 20); ctx.stroke();
    }

    // Cibo
    disegnaCella(gioco.cibo.x, gioco.cibo.y, "#ef4444", 8);

    // Effetto luce del cibo (decorativo ma non ovvio)
    const ciboX = gioco.cibo.x * 20 + 10;
    const ciboY = gioco.cibo.y * 20 + 10;
    const gradient = ctx.createRadialGradient(ciboX, ciboY, 2, ciboX, ciboY, 8);
    gradient.addColorStop(0, "rgba(255,255,255,0.8)");
    gradient.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ciboX, ciboY, 8, 0, Math.PI * 2);
    ctx.fill();

    // Serpente + occhi della testa
    gioco.serpente.forEach((p, i) => {
        const isHead = i === 0;
        const color = isHead
            ? "#10b981"
            : `rgba(52, 211, 153, ${1 - (i / gioco.serpente.length) * 0.3})`;

        disegnaCella(p.x, p.y, color, isHead ? 6 : 3);

        if (isHead) {
            // Occhi: puro effetto visivo
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(p.x * 20 + 7, p.y * 20 + 7, 2.5, 0, Math.PI * 2);
            ctx.arc(p.x * 20 + 13, p.y * 20 + 7, 2.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#1a1a1a";
            ctx.beginPath();
            ctx.arc(p.x * 20 + 7, p.y * 20 + 7, 1.2, 0, Math.PI * 2);
            ctx.arc(p.x * 20 + 13, p.y * 20 + 7, 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    scoreEl.innerText = gioco.punteggio;

    if (inPausa) {
        // Overlay di pausa (scelta intenzionale: non blocca sottoframe)
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, 400, 400);
        ctx.fillStyle = "white";
        ctx.font = "bold 32px Arial";
        ctx.textAlign = "center";
        ctx.fillText("PAUSA", 200, 200);
    }
}

/**
 * Avvia il ciclo di aggiornamento del gioco.
 * Evita automaticamente doppi avvii.
 */
function avviaTimer() {
    if (intervallo) return; // Protezione: un solo timer attivo

    intervallo = setInterval(() => {
        if (inPausa) return;

        // Direzioni multiple in buffer → evita input simultanei impossibili
        if (bufferDirezione.length > 0) {
            gioco.impostaDirezione(bufferDirezione.shift());
        }

        const esito = gioco.aggiorna();

        if (esito.morto) {
            clearInterval(intervallo);
            intervallo = null;
            bufferDirezione = [];

            // Aggiornamento high score
            if (gioco.punteggio > highScore) {
                highScore = gioco.punteggio;
                highScoreEl.innerText = highScore;
            }

            msg.innerText = "Game Over! Premi una freccia per ripartire";
        }

        disegna();
    }, gioco.velocita);
}

/**
 * Gestione input tastiera.
 * Include WASD come alias delle frecce.
 */
document.addEventListener("keydown", e => {
    // Pausa (Space)
    if (e.key === " ") {
        e.preventDefault();
        if (gioco.inCorso) {
            inPausa = !inPausa;
            disegna();
        }
        return;
    }

    let nuovaDir = null;

    switch (e.key) {
        case "ArrowUp": case "w": case "W":
            e.preventDefault();
            nuovaDir = { x: 0, y: -1 };
            break;
        case "ArrowDown": case "s": case "S":
            e.preventDefault();
            nuovaDir = { x: 0, y: 1 };
            break;
        case "ArrowLeft": case "a": case "A":
            e.preventDefault();
            nuovaDir = { x: -1, y: 0 };
            break;
        case "ArrowRight": case "d": case "D":
            e.preventDefault();
            nuovaDir = { x: 1, y: 0 };
            break;
    }

    if (nuovaDir) {
        // Primo input dopo game over → reset
        if (!gioco.inCorso) {
            gioco.reset();
            bufferDirezione = [];
            msg.innerText = "";
            gioco.impostaDirezione(nuovaDir);
            avviaTimer();
        }
        // Max 2 direzioni in buffer → evita queue infinita
        else if (bufferDirezione.length &lt; 2) {
            bufferDirezione.push(nuovaDir);
        }
    }
});

// Primo render (gioco fermo)
disegna();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="SnakeGame.html">SnakeGame</a></li></ul><h3>Global</h3><ul><li><a href="global.html#avviaTimer">avviaTimer</a></li><li><a href="global.html#bufferDirezione">bufferDirezione</a></li><li><a href="global.html#disegna">disegna</a></li><li><a href="global.html#disegnaCella">disegnaCella</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Dec 09 2025 18:49:52 GMT+0100 (Ora standard dell’Europa centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
